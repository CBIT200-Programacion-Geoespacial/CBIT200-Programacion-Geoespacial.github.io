[["principios-de-tidydata.html", "Capítulo 3 Principios de Tidydata 3.1 Definiciones 3.2 Lógica y funciones 3.3 Cambiar formato de tabla 3.4 Recursos", " Capítulo 3 Principios de Tidydata Gran parte del manejo de datos consiste en limpiar, ordenar, redistribuir, reemplazar datos. La gran mayoría de esas tareas son complejas y repetitivas. Se dice aqui que: Los principios de tidydata (datos ordenados, en castellano) proporcionan una forma estándar de organizar los valores de los datos dentro de un conjunto de datos. Un estándar facilita la limpieza inicial de los datos, ya que no es necesario empezar de cero y reinventar la rueda cada vez. El estándar tidydata se ha diseñado para facilitar la exploración y el análisis de los datos, y para simplificar el desarrollo de herramientas de análisis de datos que funcionen bien juntas. Las herramientas actuales suelen requerir traducción. Hay que dedicar tiempo a procesar los resultados de una herramienta para poder introducirlos en otra. Los conjuntos de datos ordenados y las herramientas ordenadas trabajan codo a codo para facilitar el análisis, lo que permite centrarse en la parte interesante del problema, no en lo “aburrido” de la logística de los datos. 3.1 Definiciones En el manejo estadístico de los datos estructuramos, usualmente, con tablas (dataframes) con filas y columnas. Las columnas siempre tienen títulos, aunque las filas solo a veces. Elementos de una tabla Usemos el set de datos de ejemplo llamado iris, pero le vamos a agregar un año de colecta ficticio. Para eso, vamos a crear un vector con 3 fechas asignadas de forma aleatoria a cada fila. Veamos las primeras 7 filas con la función head(). data(iris) año &lt;- sample(rep(c(&quot;2003&quot;,&quot;2013&quot;,&quot;2023&quot;), nrow(iris) / 3)) iris$Año &lt;- año kableExtra::kable(head(iris,7)) Sepal.Length Sepal.Width Petal.Length Petal.Width Species Año 5.1 3.5 1.4 0.2 setosa 2023 4.9 3.0 1.4 0.2 setosa 2003 4.7 3.2 1.3 0.2 setosa 2003 4.6 3.1 1.5 0.2 setosa 2023 5.0 3.6 1.4 0.2 setosa 2023 5.4 3.9 1.7 0.4 setosa 2013 4.6 3.4 1.4 0.3 setosa 2013 3.2 Lógica y funciones La lógica básica para el manejo de datos usando dplyr es que el resultado de una operación puede ser “conectada” a otra, lo que facilita la letura del código cuando lo revisitamos. Para eso existe una operador que hace esta conexión. 3.2.1 Funciones esenciales pipe: |&gt; group_by (agrupa datos) summarize (resume datos agrupados) filter (Encuentra filas con ciertas condiciones) select junto a starts_with, ends_with o contains mutate (Genera variables nuevas) arrange ordenar 3.2.2 pipe Esta “conexión”, se hace con este operador %&gt;% o bien |&gt;. La diferencia entre los dos es que el uso del segundo no debieras requerir pre cargar la librería y es de uso mas reciente. por ejemplo, podemos calcular el largo promedio de los petalos de las especie en el set de datos iris. library(dplyr) iris |&gt; group_by(Species) |&gt; summarize(Promedio=mean(Petal.Length)) ## # A tibble: 3 × 2 ## Species Promedio ## &lt;fct&gt; &lt;dbl&gt; ## 1 setosa 1.46 ## 2 versicolor 4.26 ## 3 virginica 5.55 3.2.3 Agrupar dplyr provee un set acotado de funciones, pero muy poderosas para manejar y ordenarnos con los datos. El ejemplo anterior muestra como se conecta una función con otra. Lo primero que hace es definir la tabla sobre la que vamos a trabajar, iris. Esta tabla es luego agrupada por la columna Species que es finalmente usada en la función summarize para calcular la media sobre los groupos de filas para cada especie. De forma similar, podriamos también buscar la varianza de todas las columnas que son de tipo numérico, adjuntar una columna con el número de filas sobre el que calculamos dicha varianza y luego imprimirla a la pantalla de forma mas estilizada. iris |&gt; group_by(Species) |&gt; summarise(across(where(is.numeric), var, na.rm = TRUE), N = n())|&gt; kableExtra::kable() |&gt; kableExtra::kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;, &quot;condensed&quot;, &quot;responsive&quot;), full_width = F) Species Sepal.Length Sepal.Width Petal.Length Petal.Width N setosa 0.1242490 0.1436898 0.0301592 0.0111061 50 versicolor 0.2664327 0.0984694 0.2208163 0.0391061 50 virginica 0.4043429 0.1040041 0.3045878 0.0754327 50 3.2.4 Filtrar Filter nos permite encontrar, y operar, solo sobre filas que cumplen una condición determinada. Por ejemplo solo un tipo de especie iris |&gt; filter(Species == &#39;virginica&#39;) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species Año ## 1 6.3 3.3 6.0 2.5 virginica 2013 ## 2 5.8 2.7 5.1 1.9 virginica 2023 ## 3 7.1 3.0 5.9 2.1 virginica 2023 ## 4 6.3 2.9 5.6 1.8 virginica 2023 ## 5 6.5 3.0 5.8 2.2 virginica 2003 ## 6 7.6 3.0 6.6 2.1 virginica 2023 ## 7 4.9 2.5 4.5 1.7 virginica 2013 ## 8 7.3 2.9 6.3 1.8 virginica 2013 ## 9 6.7 2.5 5.8 1.8 virginica 2003 ## 10 7.2 3.6 6.1 2.5 virginica 2013 ## 11 6.5 3.2 5.1 2.0 virginica 2003 ## 12 6.4 2.7 5.3 1.9 virginica 2013 ## 13 6.8 3.0 5.5 2.1 virginica 2003 ## 14 5.7 2.5 5.0 2.0 virginica 2013 ## 15 5.8 2.8 5.1 2.4 virginica 2003 ## 16 6.4 3.2 5.3 2.3 virginica 2023 ## 17 6.5 3.0 5.5 1.8 virginica 2013 ## 18 7.7 3.8 6.7 2.2 virginica 2003 ## 19 7.7 2.6 6.9 2.3 virginica 2013 ## 20 6.0 2.2 5.0 1.5 virginica 2013 ## 21 6.9 3.2 5.7 2.3 virginica 2023 ## 22 5.6 2.8 4.9 2.0 virginica 2003 ## 23 7.7 2.8 6.7 2.0 virginica 2013 ## 24 6.3 2.7 4.9 1.8 virginica 2023 ## 25 6.7 3.3 5.7 2.1 virginica 2013 ## 26 7.2 3.2 6.0 1.8 virginica 2023 ## 27 6.2 2.8 4.8 1.8 virginica 2003 ## 28 6.1 3.0 4.9 1.8 virginica 2023 ## 29 6.4 2.8 5.6 2.1 virginica 2013 ## 30 7.2 3.0 5.8 1.6 virginica 2013 ## 31 7.4 2.8 6.1 1.9 virginica 2013 ## 32 7.9 3.8 6.4 2.0 virginica 2003 ## 33 6.4 2.8 5.6 2.2 virginica 2003 ## 34 6.3 2.8 5.1 1.5 virginica 2023 ## 35 6.1 2.6 5.6 1.4 virginica 2003 ## 36 7.7 3.0 6.1 2.3 virginica 2003 ## 37 6.3 3.4 5.6 2.4 virginica 2003 ## 38 6.4 3.1 5.5 1.8 virginica 2013 ## 39 6.0 3.0 4.8 1.8 virginica 2003 ## 40 6.9 3.1 5.4 2.1 virginica 2023 ## 41 6.7 3.1 5.6 2.4 virginica 2013 ## 42 6.9 3.1 5.1 2.3 virginica 2023 ## 43 5.8 2.7 5.1 1.9 virginica 2013 ## 44 6.8 3.2 5.9 2.3 virginica 2013 ## 45 6.7 3.3 5.7 2.5 virginica 2013 ## 46 6.7 3.0 5.2 2.3 virginica 2003 ## 47 6.3 2.5 5.0 1.9 virginica 2023 ## 48 6.5 3.0 5.2 2.0 virginica 2003 ## 49 6.2 3.4 5.4 2.3 virginica 2023 ## 50 5.9 3.0 5.1 1.8 virginica 2003 Debemos tener en cuenta que si usamos filter tendremos que siempre tener un operador en el argumento de la función. En este caso era el operado == que es un igual, pero de forma literal, no como una asignación. Otro ejemplo podría ser seleccionar aquellas filas que tengan un largo de petalos mayor a 4.5, por ejemplo iris |&gt; filter(Petal.Length &gt; 4.5) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species Año ## 1 7.0 3.2 4.7 1.4 versicolor 2023 ## 2 6.9 3.1 4.9 1.5 versicolor 2023 ## 3 6.5 2.8 4.6 1.5 versicolor 2003 ## 4 6.3 3.3 4.7 1.6 versicolor 2013 ## 5 6.6 2.9 4.6 1.3 versicolor 2023 ## 6 6.1 2.9 4.7 1.4 versicolor 2023 ## 7 5.9 3.2 4.8 1.8 versicolor 2023 ## 8 6.3 2.5 4.9 1.5 versicolor 2013 ## 9 6.1 2.8 4.7 1.2 versicolor 2023 ## 10 6.8 2.8 4.8 1.4 versicolor 2003 ## 11 6.7 3.0 5.0 1.7 versicolor 2023 ## 12 6.0 2.7 5.1 1.6 versicolor 2013 ## 13 6.7 3.1 4.7 1.5 versicolor 2003 ## 14 6.1 3.0 4.6 1.4 versicolor 2003 ## 15 6.3 3.3 6.0 2.5 virginica 2013 ## 16 5.8 2.7 5.1 1.9 virginica 2023 ## 17 7.1 3.0 5.9 2.1 virginica 2023 ## 18 6.3 2.9 5.6 1.8 virginica 2023 ## 19 6.5 3.0 5.8 2.2 virginica 2003 ## 20 7.6 3.0 6.6 2.1 virginica 2023 ## 21 7.3 2.9 6.3 1.8 virginica 2013 ## 22 6.7 2.5 5.8 1.8 virginica 2003 ## 23 7.2 3.6 6.1 2.5 virginica 2013 ## 24 6.5 3.2 5.1 2.0 virginica 2003 ## 25 6.4 2.7 5.3 1.9 virginica 2013 ## 26 6.8 3.0 5.5 2.1 virginica 2003 ## 27 5.7 2.5 5.0 2.0 virginica 2013 ## 28 5.8 2.8 5.1 2.4 virginica 2003 ## 29 6.4 3.2 5.3 2.3 virginica 2023 ## 30 6.5 3.0 5.5 1.8 virginica 2013 ## 31 7.7 3.8 6.7 2.2 virginica 2003 ## 32 7.7 2.6 6.9 2.3 virginica 2013 ## 33 6.0 2.2 5.0 1.5 virginica 2013 ## 34 6.9 3.2 5.7 2.3 virginica 2023 ## 35 5.6 2.8 4.9 2.0 virginica 2003 ## 36 7.7 2.8 6.7 2.0 virginica 2013 ## 37 6.3 2.7 4.9 1.8 virginica 2023 ## 38 6.7 3.3 5.7 2.1 virginica 2013 ## 39 7.2 3.2 6.0 1.8 virginica 2023 ## 40 6.2 2.8 4.8 1.8 virginica 2003 ## 41 6.1 3.0 4.9 1.8 virginica 2023 ## 42 6.4 2.8 5.6 2.1 virginica 2013 ## 43 7.2 3.0 5.8 1.6 virginica 2013 ## 44 7.4 2.8 6.1 1.9 virginica 2013 ## 45 7.9 3.8 6.4 2.0 virginica 2003 ## 46 6.4 2.8 5.6 2.2 virginica 2003 ## 47 6.3 2.8 5.1 1.5 virginica 2023 ## 48 6.1 2.6 5.6 1.4 virginica 2003 ## 49 7.7 3.0 6.1 2.3 virginica 2003 ## 50 6.3 3.4 5.6 2.4 virginica 2003 ## 51 6.4 3.1 5.5 1.8 virginica 2013 ## 52 6.0 3.0 4.8 1.8 virginica 2003 ## 53 6.9 3.1 5.4 2.1 virginica 2023 ## 54 6.7 3.1 5.6 2.4 virginica 2013 ## 55 6.9 3.1 5.1 2.3 virginica 2023 ## 56 5.8 2.7 5.1 1.9 virginica 2013 ## 57 6.8 3.2 5.9 2.3 virginica 2013 ## 58 6.7 3.3 5.7 2.5 virginica 2013 ## 59 6.7 3.0 5.2 2.3 virginica 2003 ## 60 6.3 2.5 5.0 1.9 virginica 2023 ## 61 6.5 3.0 5.2 2.0 virginica 2003 ## 62 6.2 3.4 5.4 2.3 virginica 2023 ## 63 5.9 3.0 5.1 1.8 virginica 2003 3.2.5 Crear nuevas variables Con mutate() podemos crear una nueva columna de forma explícita. Por ejemplo, si quisieramos saber cuales son las especies y años en que se colectaron especies con una razon largo/ancho determinado. iris |&gt; mutate(Petal.Ratio = Petal.Length/Petal.Width)|&gt; select(Petal.Ratio,Species,Año) |&gt; group_by(Species,Año) |&gt; summarize(Petal.Ratio.Mean = mean(Petal.Ratio)) |&gt; filter(Petal.Ratio.Mean &gt; median(Petal.Ratio.Mean)) ## `summarise()` has grouped output by &#39;Species&#39;. You can override using the ## `.groups` argument. ## # A tibble: 3 × 3 ## # Groups: Species [3] ## Species Año Petal.Ratio.Mean ## &lt;fct&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 setosa 2023 7.75 ## 2 versicolor 2003 3.27 ## 3 virginica 2013 2.85 3.2.6 Responder: ¿Escriba la pregunta que responde el análisis? En función del último análisis, ¿existe diferencia interespecífica en la relación entre largo y ancho largo para estes grupo de especies? -¿Cómo formularías la pregunta anterior de forma mas precisa en función del análisis anterior? 3.3 Cambiar formato de tabla Muchas veces es necesario reorientar la tabla de datos. Primero, podríamos interesarnos en definir clases para las muestras. Definimos tamaños como clases usando terciles. etiquetas &lt;- c(&quot;alto&quot;,&quot;medio&quot;,&quot;bajo&quot;) miIris &lt;- iris |&gt; mutate(Tamaño = factor(ntile(Petal.Length/Petal.Width,3),ordered = TRUE, labels = etiquetas)) Luego vamos a re-orientar la tabla de manera a poder indagar si existe diferencia entre especies respecto de la característica Tamaño miIris |&gt; select(Species, Año,Tamaño,Sepal.Width) |&gt; tidyr::pivot_wider(names_from = Tamaño, values_from = Sepal.Width,values_fn=mean) ## # A tibble: 9 × 5 ## Species Año bajo medio alto ## &lt;fct&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 setosa 2023 3.47 NA NA ## 2 setosa 2003 3.34 3.85 3.5 ## 3 setosa 2013 3.37 3.9 NA ## 4 versicolor 2023 2.8 2.72 2.95 ## 5 versicolor 2013 2.7 2.56 3.07 ## 6 versicolor 2003 2.2 2.81 2.7 ## 7 virginica 2013 NA 2.83 2.97 ## 8 virginica 2023 NA 2.98 2.99 ## 9 virginica 2003 2.6 3.15 3.04 3.3.1 ¿Podemos explicar que sucedió aquí? ¿En qué caso aparecen los NA? ¿Qué tipo de gráfico evidenciaría la relación entre el ratio largo:ancho del pétalo y el ancho del sépalo? grafica 3.4 Recursos data wrangling cheatsheet [tablas bonitinhas con Kable] (https://haozhu233.github.io/kableExtra/awesome_table_in_html.html) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
