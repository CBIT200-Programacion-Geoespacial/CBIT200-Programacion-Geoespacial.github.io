{"title":"Autocorrelación espacial","markdown":{"yaml":{"title":"Autocorrelación espacial","author":"Derek Corcoran","date":"`r format(Sys.time(), '%d/%m, %Y')`","output":{"ioslides_presentation":{"widescreen":true,"incremental":true}}},"headingText":"Todo está relacionado con todo lo demás, pero las cosas cercanas están más relacionadas que las distantes","containsRefs":false,"markdown":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = FALSE, tidy = TRUE, tidy.opts= list(blank = FALSE, width.cutoff = 60), eval =FALSE)\n\nlibrary(gstat)\nlibrary(raster)\nlibrary(rgdal)\nlibrary(rworldxtra)\nlibrary(sf)\nlibrary(tidyverse)\n\nlibrary(leaflet)\nlibrary(kableExtra)\noptions(\"kableExtra.html.bsTable\" = T)\n```\n\n\nLey de Tobler (Primera ley de la Geografía)\n\n## Autocorrelación espacial\n\n```{r, echo = T, eval = F}\nlibrary(gstat)\nlibrary(raster)\nlibrary(rgdal)\nlibrary(rworldxtra)\nlibrary(sf)\nlibrary(sp)\nlibrary(tidyverse)\n```\n\n-   A veces el fenomeno tiene más que ver con proximidad que con condiciones\n\n-   Figura de COVID o de vicarianza\n\n## Base de datos meuse\n\n```{r}\ndata(meuse)\nMeuse <- st_as_sf(meuse, coords = c(1,2), crs = \"+init=epsg:28992\")\ncoordinates(meuse) = ~x+y\nproj4string(meuse) <- CRS(\"+init=epsg:28992\")\nggplot() + geom_sf(data = Meuse, aes(color = zinc)) + theme_bw()\n```\n\n## Donde queda meuse?\n\n```{r, echo = F}\nleaflet(as_Spatial(st_transform(Meuse, crs = 4326))) %>% addTiles() %>% addCircles()\n```\n\n## Variogramas\n\n```{r}\n# Modelo nulo\nZ_vgm_null <- variogram(log(zinc)~1, meuse) \n```\n\n```{r, echo = FALSE, fig.height= 4.5}\nggplot(Z_vgm_null, aes(x = dist, y = gamma)) + geom_point() + theme_bw()  + xlab(\"Ditancia metros\") + ylim(c(0,max(Z_vgm_null$gamma)))\n```\n\n## Variogramas\n\n```{r}\n# Modelo nulo\nZ_vgm_null <- variogram(log(zinc)~1, meuse) %>% mutate(Modelo = \"Nulo\")\n#Modelo Espacial\nZ_vgm_Spat <- variogram(log(zinc)~x+y, meuse) %>% mutate(Modelo = \"Espacial\")\n# Modelo distancia\nZ_vgm_Dist <- variogram(log(zinc)~dist, meuse) %>% mutate(Modelo = \"distancia\")\n## Modelo sqrt Dist\nZ_vgm_Dist_sq <- variogram(log(zinc)~sqrt(dist), meuse) %>% mutate(Modelo = \"sqrt(dist)\")\n\nZ_vgm <- list(Z_vgm_Dist, Z_vgm_null, Z_vgm_Spat, Z_vgm_Dist_sq) %>% reduce(bind_rows)\n```\n\n## Variograma\n\n```{r, echo = FALSE}\nggplot(Z_vgm, aes(x = dist, y = gamma)) + geom_point(aes(color = Modelo)) + theme_bw()  + xlab(\"Ditancia metros\") + ylim(c(0,max(Z_vgm$gamma)))\n```\n\n# Dudas\n\n## Variogram\n\n```{r}\nAbn_fit_Spat <- fit.variogram(Z_vgm_Spat, model=vgm(1, \"Sph\", 700, 1))\n\nAbn_fit_Spat\n```\n\n## fitted variogram\n\n```{r, echo = F}\nggplot(variogramLine(Abn_fit_Spat, 1600), aes(x = dist, y = gamma)) + geom_path() + geom_point(data = Z_vgm_Spat, color = \"red\") + geom_vline(xintercept = Abn_fit_Spat$range[2], lty = 2) + geom_text(x = Abn_fit_Spat$range[2], y = Abn_fit_Spat$psill[2]/2, label = \"range\") + theme_bw() + geom_hline(yintercept = Abn_fit_Spat$psill[2] + Abn_fit_Spat$psill[1] , lty = 2) + geom_text(x = Abn_fit_Spat$range[2]/2, y = Abn_fit_Spat$psill[2] + Abn_fit_Spat$psill[1], label = \"psill\") + geom_text(x = Abn_fit_Spat$range[1], y = Abn_fit_Spat$psill[1], label = \"Nugget\") + ylim(c(0,max(Z_vgm_Spat$gamma)))\n```\n\n## Todos\n\n```{r}\nAbn_fit_null <- fit.variogram(Z_vgm_null, model=vgm(1, \"Sph\", 700, 1))\n\nAbn_fit_Spat <- fit.variogram(Z_vgm_Spat, model=vgm(1, \"Sph\", 700, 1))\n\nAbn_fit_Dist <- fit.variogram(Z_vgm_Dist, model=vgm(1, \"Sph\", 700, 1))\n\nAbn_fit_Dist_sq <- fit.variogram(Z_vgm_Dist_sq, model=vgm(1, \"Sph\", 700, 1))\n```\n\n## Predicciones para todos\n\n```{r, echo = F}\nAbn_line_null <- variogramLine(Abn_fit_null, 1600) %>% mutate(Modelo = \"Nulo\")\n\nAbn_line_Spat <- variogramLine(Abn_fit_Spat, 1600) %>% mutate(Modelo = \"Espacial\")\n\nAbn_line_Dist <- variogramLine(Abn_fit_Dist, 1600) %>% mutate(Modelo = \"distancia\")\n\nAbn_line_Dist_sq <- variogramLine(Abn_fit_Dist_sq, 1600) %>% mutate(Modelo = \"sqrt(dist)\")\n\nAbn_line <- list(Abn_line_null, Abn_line_Spat, Abn_line_Dist, Abn_line_Dist_sq) %>% reduce(bind_rows)\n\nggplot(Abn_line, aes(x = dist, y = gamma)) + geom_path(aes(color = Modelo)) + geom_point(data = Z_vgm, aes(color = Modelo)) + theme_bw()\n\n```\n\n## Kriging\n\n```{r}\ndata(meuse.grid)\nMeuse_Grid <- st_as_sf(meuse.grid, coords = c(1,2), crs = \"+init=epsg:28992\")\ncoordinates(meuse.grid) = ~x+y\nproj4string(meuse.grid) <- CRS(\"+init=epsg:28992\")\n\n\nggplot() + geom_sf(data = Meuse_Grid, aes(color = dist)) + scale_color_viridis_c()\n```\n\n## Predicción\n\n```{r, message=F, results='hold'}\nSpat_pred <- krige(log(zinc)~x+y, meuse, meuse.grid, model = Abn_fit_Spat) %>% st_as_sf()\n```\n\n## Resultado\n\n```{r}\nggplot() + geom_sf(data = Spat_pred, aes(color = exp(var1.pred))) + scale_color_viridis_c(name = \"[Zinc]\")+ theme_bw()\n```\n\n## Varianza\n\n```{r}\nggplot() + geom_sf(data = Spat_pred, aes(color = var1.var)) + scale_color_viridis_c()+ theme_bw()\n```\n\n## Predicción todos juntos\n\n```{r}\nNull_pred <- krige(log(zinc)~1, Meuse, Meuse_Grid, model = Abn_fit_null) %>% mutate(Modelo = \"Nulo\")\n\nSpat_pred <- krige(log(zinc)~x + y, meuse, meuse.grid, model = Abn_fit_Spat) %>% st_as_sf() %>% mutate(Modelo = \"Espacial\")\n\nDist_pred <- krige(log(zinc)~dist, Meuse, Meuse_Grid, model = Abn_fit_Dist) %>% mutate(Modelo = \"distancia\")\n\nDist_sq_pred <- krige(log(zinc)~sqrt(dist), Meuse, Meuse_Grid, model = Abn_fit_Dist_sq)  %>% mutate(Modelo = \"sqrt(dist)\")\n\nPred <- list(Null_pred, Spat_pred, Dist_pred, Dist_sq_pred) %>% reduce(bind_rows)\n```\n\n## Predicciones\n\n```{r}\nggplot() + geom_sf(data = Pred, aes(color = exp(var1.pred))) + scale_color_viridis_c(name = \"[Zinc]\") + facet_wrap(~Modelo)  + theme_bw()\n```\n\n## Variaciones\n\n```{r}\nggplot() + geom_sf(data = Pred, aes(color = var1.var)) + scale_color_viridis_c() + facet_wrap(~Modelo)  + theme_bw()\n```\n\n# ¿Cómo elijo el mejor modelo?\n\n## RMSE\n\n-   Root Mean Square Error\n\n$$RMSE = \\sqrt{ \\frac{1}{N}\\sum_{i=1}^{N} (x_{i})^2}$$\n\n-   Donde x es el error\n-   Cross validation\n    -   Entrenamos el modelo con algunos datos y dejamos otros\n    -   Vemos el error al predecir los datos faltantes\n\n## krige.cv\n\n```{r}\nNull_CV <- krige.cv(log(zinc)~1, meuse, model = Abn_fit_null, nfold = 5) %>% st_as_sf() %>% mutate(Modelo = \"Nulo\")\n\nSpat_CV <- krige.cv(log(zinc)~x+y, meuse, model = Abn_fit_Spat, nfold = 5) %>% st_as_sf() %>% mutate(Modelo = \"Espacial\")\n\nDist_CV <- krige.cv(log(zinc)~dist, meuse, model = Abn_fit_Dist, nfold = 5) %>% st_as_sf() %>% mutate(Modelo = \"distancia\")\n\nDist_sq_CV <- krige.cv(log(zinc)~sqrt(dist), meuse, model = Abn_fit_Dist_sq, nfold = 5) %>% st_as_sf() %>% mutate(Modelo = \"sqrt(dist)\")\n\nPred_CV <- list(Null_CV, Spat_CV, Dist_CV, Dist_sq_CV) %>% reduce(bind_rows)\n```\n\n## Folds?\n\n```{r, echo = F}\nggplot() + geom_sf(data = Spat_CV, aes(color = as.factor(fold))) + facet_wrap(~fold) + theme_bw() + scale_color_viridis_d()\n```\n\n## Reumen y orden por RMSE\n\n```{r}\nResumen <- Pred_CV %>% as.data.frame() %>% \n  group_by(Modelo) %>% \n  summarise(RMSE = sqrt(sum(residual^2)/length(residual))) %>% arrange(RMSE)\n```\n\n```{r}\nkable(Resumen) %>% kable_styling()\n```\n\n## Podemos hacer algunos diagnósticos\n\n```{r, echo = FALSE}\nggplot(Dist_CV, aes(y = var1.pred, x = observed)) + geom_smooth(method = \"lm\")+ geom_point() + theme_bw()\n```\n\n## Entonces, ¿Hay estructura espacial?\n\n```{r}\nVar <- variogram(residual~1, Dist_CV)\nggplot(Var, aes(x = dist, y = gamma)) + geom_point() + theme_bw()  + xlab(\"Ditancia metros\") + ylim(c(0,max(Var$gamma)))\n```\n\n## Nos quedamos con la distancia\n\n```{r, echo = F}\nggplot() + geom_sf(data = Dist_pred, aes(color = exp(var1.pred))) + scale_color_viridis_c(name = \"[Zinc]\")+ theme_bw()\n```\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":{"ioslides_presentation":{"widescreen":true,"incremental":true}},"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"Clase9_Autocor.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.335","theme":"cosmo","title":"Autocorrelación espacial","author":"Derek Corcoran","date":"`r format(Sys.time(), '%d/%m, %Y')`"},"extensions":{"book":{"multiFile":true}}}}}